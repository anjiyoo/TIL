2진법을 사용하는 비트로 특정 수를 표현하는 방법이다.

<br>

### 양의 정수 표현

일상 생활에서 사용하는 10진수 체계는 10가지 기호인 숫자(0~9)를 상자에 담을 수 있다.

![image1](https://github.com/user-attachments/assets/8cc1aa02-7fde-428b-b221-91f79932f2ae)

`(1000(=10^3) x 5) + (100(=10^2) x 0) + (10(=10^1) x 2) + (1(=10^0) x 8) = 5,028` 5,028은 각 상자 위치에 해당하는 밑(base)의 거듭제곱과 각 자리에 들어간 수를 곱한 값들의 합이다.

5,028을 2진수로 나타내보자. 0으로 표현된 자리를 제외하고 유효한 값만 식으로 풀어쓴다면, `(2^12 x 1) + (2^9 x 1) + (2^8 x 1) + (2^7 x 1) + (2^5 x 1) + (2^2 x 1)`로 나타낼 수 있다.

![image2](https://github.com/user-attachments/assets/f7f1bcae-4035-4bf4-91f9-f70aa8a4fc37)

10진수에서는 5,028이 4자리 숫자이지만, 이처럼 2진수로 동일한 값을 표현하면 13자리 숫자(13비트 수)가 된다.

2진수 비트로 표현된 수에서 가장 오른쪽(가장 작은 자릿수)의 비트를 `LSB(Least Significant Bit)`, 반대로 가장 왼쪽(가장 큰 자릿수)의 비트를 `MSB(Most Significant Bit)`라고 부른다.

<br>

### 2진수 덧셈

덧셈이라면 작은 자리의 수부터 더하고 해당 자릿수를 넘어가면 좌측으로 넘기는 방식으로 동일하다. LSB부터 MSB 쪽으로 더하며 최대 수인 1을 넘으면 그 다음 자리로 넘긴다.

> 10진수: 1 + 5 = 6
>
> 2진수: 001(=1) + 101(=5) = 110(=6)

`AND`와 `XOR` 논리 연산자로 2진수의 각 자리 덧셈을 수행할 수 있다. `AND`로 동일한 자리의 수를 비교한 결과를 좌측에, `XOR`로 비교한 결과를 우측에 위치시키고 붙여쓴다.

덧셈의 결과가 사용할 수 있는 비트 수를 초과할 경우 `오버플로우(overflow)`가 발생한다. 오버플로우는 MSB에서 올림이 발생했다는 뜻이다. 컴퓨터에는 `조건 코드 레지스터(condition code register)`라는 곳에 `오버플로우 비트`를 담고 있고, 이 비트에는 MSB에서 발생한 올림 값이 들어간다. 이 비트 값을 통해 오버플로우가 발생했는지 여부를 알 수 있다.

`조건 코드 레지스터(Condition code register, CCR)`란, 연산 결과에 따라 CPU에 의해 세트되는 비트들을 저장하는 레지스터라고 한다. 보통 CPU라고 부르는 `프로세서(Processor)`는 제어 장치, 연산 장치, 레지스터, 데이터 버스로 구성된 디지털 시스템의 핵심 부분으로 프로그램을 기억 장치로부터 읽어 연산 처리, 비교 처리, 데이터 전송, 편집, 변환, 테스트와 분기 등의 데이터를 처리하고 각종 장치를 구동하는 역할을 한다.

레지스터는 프로세서의 구성 중 하나이다. 프로세서가 반복적 또는 주기적으로 처리하는 도중의 일시적인 정보는 이 레지스터에 저장해 효율적으로 작동한다. 레지스터는 플립플롭(flip-flop)으로 구성되어 있으며, 레지스터의 여러 종류 중 하나가 조건 코드 레지스터 이다.

조건 코드 레지스터는 총 4가지가 있다.

> 1.`CF(Carry Flag)`: MSB에서 Carry out 또는 Borrow 발생 시 저장
>
> 2.`ZF(Zero Flag)`: 결과 값 0인 경우 저장
>
> 3.`SF(Sign Flag)`: 부호를 나타내며, 결과 값의 MSB가 1일 경우 저장
>
> 4.`OF(Overflow Flag)`: 오버플로우 발생 시 저장

<br>

### 음수 표현

비트에서도 MSB에 부호의 역할을 부여해 구분할 수 있다.

> 부호와 크기
- +5 표현 = 0101
- 5 표현 = 1101

`0`은 `+` 역할로 `1`은 `-` 역할로 나타낸다. 비트 하나를 부호 역할로 사용하고 나머지 비트로 수를 표현하는 방법을 `부호와 크기(Sign and Magnitude) 표현법`이라고 한다. 하지만 이 방법은 같은 개념의 수를 표현하기 위해 비트 하나를 추가로 낭비해서 잘 사용하지 않는 방법이다.

> 1의 보수
- +7 표현 = 0111
- 7 표현 = 1000

양수의 모든 비트를 1에서 0, 0에서 1로 모두 뒤집어 표현하는 `1의 보수(one's complement) 표현법`이다. `NOT` 연산을 통해 보수를 얻는다. 각 비트의 수를 서로 반대로 뒤집는 것이다. MSB에서 올림이 발생한 경우 다시 LSB로 전달하는 `순환 올림(End-around carry)`을 해야 한다. 이 방법 또한, 계산 과정이 필요하기 때문에 추가 하드웨어가 필요하다.

> 2의 보수
- +4 표현 = 0100
- 4 표현 = 1011, 0001 이 2진수를 합한 값이 -4

현대 컴퓨터에서는 부호와 크기 표현법과 1의 보수 표현법을 모두 사용하지 않는다. 추가 하드웨어나 비용없이 `AND`와 `XOR` 연산자로 계산할 수 있는 `2의 보수(two's complement) 표현법`이 있다. 2의 보수 표현법에서는 양수 1에 더했을 때 0이 나오도록 하는 숫자 -1을 나타내는 비트 패턴을 찾아 활용한다. 우선 1의 보수 표현법과 동일하게 MSB를 부호로 사용한다. 4비트 수에서 `1111`을 더한다. 1111을 2의 보수 표기법에서는 `-1`로 정한다. 특정 양수와 같은 절댓값의 음수를 구하려면 0과 1을 서로 뒤집은 다음 2진수 1을 더한다.