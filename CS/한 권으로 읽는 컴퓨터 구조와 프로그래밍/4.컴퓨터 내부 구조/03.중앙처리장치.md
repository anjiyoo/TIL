### 중앙처리장치
중앙 처리 장치 CPU는 실제 계산을 처리하는 컴퓨터 부품이다. CPU는 다음과 같이 다양한 요소로 이루어져 있다.

<br>

### 산술 논리 장치 _ ALU (arithmetic logic unit)
CPU의 핵심 부품으로 산술 계산, 불리언 대수 및 기타 연산을 수행하는 방법을 알고 있는 장치이다.

- 피연산자 : 수를 표현하는 비트
- 연산 코드(명령 코드) ****: 피연산자에 대해 ALU가 어떤 연산자를 적용할지 지정한다.
- 결과 : 피연산자에 연산자를 적용한 결과
- 조건 코드 : 결과에 대한 추가 정보. 보통 조건 코드 레지스터라는 레지스터에 저장된다.

> 조건 코드 레지스터

*이미지추가

박스 위의 숫자는 비트 번호이다. 비트 번호로 각 비트를 편리하게 가리킨다. 

비트 중 일부는 사용하지 않는다.

- N 비트 ****: 마지막으로 수행한 연산 결과가 `음수`인 경우 1이 된다.
- Z 비트 ****: 마지막 연산 결과가 `0`인 경우 1이 된다.
- O 비트 ****: 마지막 연산에서 `오버플로우(overflow)`, `언더플로우(underflow)`가 생긴 경우 1이 된다.

> ALU 명령 코드

*이미지추가

<br>

### 시프트

왼쪽 시프트 혹은 오른쪽 시프트 시 사라지는 비트는 종종 필요할 때가 있다. 그래서 이 비트를 `조건 레지스터`에 저장한다.

**순차적인 시프트 레지스터** 시프트를 제외한 ALU의 모든 기능은 조합 논리로 구현할 수 있다.

> 왼쪽 시프트
왼쪽 시프트 혹은 오른쪽 시프트 시 사라지는 비트는 종종 필요할 때가 있다. 그래서 이 비트를 `조건 레지스터`에 저장한다.

- 어떤 숫자의 모든 비트를 왼쪽으로 1비트씩 옮긴다.
- 맨 왼쪽 비트는 버린다.
- 비게 되는 가장 오른쪽 비트에 0을 넣는다. ex) 01101001(105) => 11010010(210)
    - 어떤 수를 1비트 `왼쪽 시프트` 한다. = 그 수에 `2를 곱한 것`과 같다.

> 오른쪽 시프트
- 어떤 숫자의 모든 비트를 오른쪽으로 1비트씩 옮긴다.
- 맨 오른쪽 비트는 버린다.
- 비게되는 가장 왼쪽 비트에 0을 넣는다. ex) 01101001(105) => 00110100(52)
    - 어떤 수를 `오른쪽 시프트` 한다. = 그 수를 `2로 나누고 나머지를 버린 값`과 같다.

> 순차적인 시프트 레지스터

*이미지추가

위와 같이 클록에 따라 내용을 1비트씩 시프트 하는 시프트 레지스터를 `플리플롭`을 이용해 만들 수 있다. 여기서 1비트를 시프트 할 때, 1 클록이 필요하기 때문에 느리다.

> 베럴 시프터

*이미지추가

8비트 시프터를만들려면, 8:1 실렉터가 8개 필요하다.

배럴 시프터와 가산기를 조합하는 `조합논리 곱셈기`를 만들 수 있다.

또, 시프터를 이용해 부동 소수점 연산을 구현할 때도 핵심 부품이다. 두 피연산자의 가수를 지수에 따라 시프트 해 소수점을 정렬하고, 서로 더하거나 뺀다.

<br>

### 실행 장치 (Execution unit, 제어장치)

메모리의 정해진 장소에서 `명령 코드`와 `피연산자`를 가져와 `ALU`에게 어떤 연산을 수행할지 알려주고, 결과를 메모리에 돌려준다.

> 명령어
- 컴퓨터에게 어떤 일을 할지 알려주는 `비트 패턴`
- 명령어의 `비트 패턴`은 CPU마다 고유한 설계에 속한다.
- 공통 표준이 없다

> 프로그램 저장 방식 컴퓨터 (program counter, PC)
- 실행 장치는 `프로그램 저장 방식 컴퓨터`(stored-program computer)를 이용해 메모리에서 명령어를 찾는다.
- 레지스터의 일종으로 메모리와 별도로 위치한다. `순수 레지스터`가 아닌 `레지스터`에 `카운터` 기능을 추가한 것이다.
- `메모리 주소`가 들어있어, 실행장치가 PC가 가리키는 `주소`에서 명령어를 가져온다.
- 명령을 수행하고 하면 다음 명령어를 가져오기 위해 `PC가 증가`한다.
- CPU마다 `초기 PC 값`이 있어, CPU의 전원이 들어오면 이 값으로 PC가 설정된다. (이 때 PC 값을 `리셋 벡터`라고 부른다.)