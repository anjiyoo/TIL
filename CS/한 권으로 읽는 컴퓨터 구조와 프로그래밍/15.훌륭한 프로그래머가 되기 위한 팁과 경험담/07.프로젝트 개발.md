먼저 프로그래밍 환경으로는 리눅스를 비롯한 유닉스 파생 환경을 선택하는 것이 좋다. 여러 방법으로 유닉스 환경을 사용할 수 있다. Mac OS는 유닉스를 기반으로 만들어졌고, PC에 리눅스를 설치할 수도 있다. `가상 머신(Virtual Machine)`에 리눅스를 설치할 수 있는데, 가상 머신은 컴퓨터에서 실행되는 윈도우 안에 다른 운영체제를 설치해 실행할 수 있게 하는 소프트웨어이다.

<br>

### 나이 든 개발자의 잡설
프로그래밍을 하기 위해서는 여러 툴을 다룰 수 있어야 한다. 책에서는 단순히 숙제를 타이핑하거나 비디오를 보는 것보다 훨씬 더 많은 일을 하기 위해 전동 공구를 다루는 방법을 배울 때가 됐다고 비유한다.

> 터미널과 셀

모든 컴퓨터 시스템에는 터미널이 있다. 기본적으로 터미널은 `명령 해석기(command interpreter)`를 실행한다. 사용자에게는 명령 프롬프트가 표시된다. 유닉스 기반 시스템에는 명령 해석기로 `쉘(shell)`이 있다. 보통 `배시(bash)`라는 쉘을 사용한다.

많은 명령어들이 축약어로 이루어져 있다. 예를 들어, 흔히 볼 수 있는 `grep`은 `global regular expression printer`의 약자이다. 보통 최초 발견자의 이름을 따라 붙인다고도 한다.

이런 명령어를 배우는 주된 이유는 `자동화`이다. 쉘이 제공하는 기능 중에는 명령을 파일에 넣어서 실행될 수 있는 프로그램을 만드는 기능이 있다. 이런 기능으로 명령을 직접 만들어 사용해 활용한다면, 훨씬 더 생산적으로 작업할 수 있다.

> 텍스트 편집기

텍스트 편집기는 텍스트 데이터를 만들거나 편집할 수 있게 하는 프로그램이다. 역사적으로 유명한 텍스트 편집기로는 `vi`와 `Emacs`가 있으며, 최근 많이 쓰이는 편집기로는 비쥬얼 스튜디오 코드, 노트패드++, 아톰, 브래킷츠 등이 있다고 한다.

또한, Eclipse, Visual Studio, IntelliJ IDEA는 통합 개발 환경(IDE: integrated development environment)이라고 불리는 도구이다.

<br>

### 이식성이 있는 코드
작성한 코드가 만약 오픈소스라면, 다른 사람들이 그 코드를 사용하려고 할 수도 있다. `하드와이어링(hard wiring)`을 최대한 피해야 작성한 코드를 다른 곳으로 포팅하기가 수월하다. 하드와이어링은 전자 회로 용어지만, 여기서는 특정 시스템에 종속된 값을 직접 쓰거나 특정 시스템 환경을 가정하고 코드를 작성하는 등, 처음 소스 코드가 작성된 환경이 아닌 다른 곳으로 가면 바뀔 수 있는 부분을 너무 강하게 고정해두는 행위를 표현했다.

하드웨어는 비트나 바이트 배열 순서, 워드 크기 등 여러 가지 측면에서 달라질 수 있다. 이와 별개로 프로그래밍 언어가 하드웨어를 프로그래머에게 드러내는 방식도 다르다.

실행 환경의 차이 중에는 쉽게 처리하기 어려운 것들도 있는데, 그럴 때는 의존관계를 여러 곳에 분산시키는 대신 한곳에 모아두는 것이 좋다. 한곳에 모아두면 누군가가 원하는 시스템에 맞춰 쉽게 의존관계를 변경할 수 있다.

<br>

### 소스 코드 제어
프로그램에 기능을 추가하거나 버그를 수정하기 위해 변경하는 등 여러 가지 작업을 하게 된다. 이때 이전 버전의 소스 코드를 추적하고 어떤 부분이 변경됐는지 확인해야 하기 때문에 소스 코드를 과거로 돌릴 수 있는 것이 중요하다.

1970년대 초에는 두 파일을 비교해서 달라진 부분의 목록을 생성하는 `diff`라는 프로그램이 만들어졌고, 마크 로치카인드는 diff 아이디어를 바탕으로 `소스 코드 제어 시스템(SCCS: Source Code Control System)`을 만들었다. SCCS는 파일이 바뀔 때마다 복사본을 남기는 대신, 원본과 각 버전의 변경 목록을 저장했다. 사용자가 어떤 버전의 파일을 요구하면 원본에 모든 변경 버전을 적용해서 그 자리에서 만든 버전의 파일을 얻을 수 있었다.

1982년에는 월터 티치가 `변경 제어 시스템(RCS: Revision Control System)`을 발표했다. RCS는 더 나은 사용자 인터페이스를 제공하고, SCCS가 사용하던 전방 변경 이력 대신 후반 변경 이력을 채택했다.

SCCS와 RCS는 한 컴퓨터 안에서만 잘 작동했다. 딕 그룬은 `동시성 버전 제어 시스템(CVS: Concurrent Versioning System)`을 개발했다. CVS는 RCS와 비슷한 기능을 네트워크로 접근할 수 있게 해주면서 최초로 파일 잠금 대신 병합(merge)을 사용한 시스템이다.

SCCS와 RCS는 파일을 잠그기 때문에 대규모로 사용하기가 어려웠다. 사용자는 파일을 체크아웃하고 변경 후에는 체크인한다. 체크아웃된 파일은 잠기기 때문에 다른 사람이 편집할 수가 없다. 이런 한계를 극복하기 위해 Subversion, Bitkeeper, Git 등의 `분산 시스템`이 만들어졌다. 이는 잠금 방식의 문제점을 병합 방식으로 해결했다.

<br>

### 테스트
프로그램을 작성할 때 테스트 집합도 만들어야 한다. `TDD(Test Driven Development)`라는 방법론도 존재하듯 테스트부터 시작하기도 한다. 테스트도 소스 코드 제어 시스템에 등록해야 한다. 쉘 스크립트나 배치 파일 등을 통해 전체 테스트를 한꺼번에 실행할 수 있는 명령을 만들 수 있고, GUI나 명령줄 빌드 도구가 전체 테스트 실행을 지원하기도 한다.

`나이틀리 빌드(nightly build)`를 하면 유용할 때가 있다고 한다. 나이틀리 빌드는 매일 정해진 시간에 프로그램을 빌드하고 테스트를 실행한다. `회귀 테스트(regression test)`는 변경한 코드가 잘 작동하던 부분을 깨지는 않았는지 검증하는 과정이다. 수정된 버그가 다시 나오지는 않는지 확인할 때 도움된다고 한다.

가능하면 테스트 코드는 다른 사람이 작성하는 것이 좋다. 코드를 작성한 사람은 무의식 중에 자신의 코드에 있는 문제를 보지 못할 수 있기 때문에 테스트를 작성할 때도 보지 못할 가능성이 있기 때문이다.

<br>

### 버그 보고와 추적
테스트와 별개로 사용자도 버그를 찾는다. 사용자가 발견한 버그를 보고하고, 이런 버그를 어떠헥 고쳤는지 추적하는 도구도 필요하다.

이런 도구를 `버스 추적 시스템(bug tracking system)`이나 `이슈 추적 시스템(issue tracking system)`이라고 부른다. Github과 같이 웹을 기반으로 만들어진 소스 코드 버전 제어 시스템은 프로젝트 레포지토리에 이슈 추적 기능을 함께 제공하기도 한다.

<br>

### 리팩토링
코드의 인터페이스나 동작은 바꾸지 않고 코드 내부를 재작성해 개선하는 과정이다. 리팩토링을 하는 주된 이유는 코드가 완전히 구체화되면 코드가 지저분해지거나 좀 더 낫게 문제를 처리하는 방법을 알게 되는 경우가 있기 때문이다. 리팩토링을 하면 유지보수 비용을 줄일 수 있다. 효과적인 리팩토링을 위해서는 좋은 테스트 집합이 필요하며, 리팩토링 과정에서 새로운 기능을 추가하고 싶더라도 자제해야 한다.

<br>

### 유지보수
개발에 드는 비용보다 유지보수에 드는 비용이 훨씬 더 큰 경우도 있다. 처음부터 유지보수가 필요없을 정도의 코드를 작성하려고 하는 것을 피하라고 한다. 유지보수를 하는 사람이 이해하지 못한다면 코드를 보고 새로 설계해야 할 수도 있기 때문이다.

현실에서는 누구든지 코드의 어떤 부분이든 빠르게 살펴보고 무슨 일을 하는지 이해할 수 있는 것이 더 중요하다. 쉽게 이해할 수 있는 코드를 작성하는 것으로부터 가치를 찾아야 한다.

코드가 하드웨어와 통신해야 하는 경우, 코드 안에 하드웨어 데이터시트에 대한 참조를 포함하는 것이 유지보수 담당자에게 도움될 수 있다. 레지스터를 건드려야 한다면 해당 레지스터에 대한 설명이 들어 있는 데이터시트 페이지를 포함하는 것이 좋다.