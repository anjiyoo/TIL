![image55](https://github.com/user-attachments/assets/d3501b22-c2da-4c1b-9378-4546996f56a7)

- 첫 번째 방법의 문제점
    - 쿠키를 다 만들기 전까지는 소포를 받아볼 수 없다.
- 두 번째 방법의 문제점
    - 쿠키를 만드는 모든 단계마다 소포가 왔는지 안 왔는지 확인하는 시스템으로 (`polling` 이라고 부름) 소포를 못 받을 가능성은 줄어들지만 문 앞에 누가 왔는지 검사하는데 너무 많은 시간을 소모하게 된다.
- 결론
    - 소프트웨어적으로 이 문제를 해결할 수 있는 방법은 없다.때문에, 실행 중인 프로그램을 잠깐 중단(`interrupt`)시키고 외부의 요소에 대응할 수 있게 하는 방법이 존재한다.
    
    ```
    우선적으로 처리해야하는 태스크가 있어서 프로그램의 실행을 잠깐 중단하는 것을 '인터럽트한다' 라고 표현
    ```

<br>

### 인터럽트 시스템

요즘 쓰이는 프로세서 대부분은 인터럽트(`interrupt`) 시스템이 들어간다.

인터럽트 시스템은 적절한 신호가 들어오면 CPU 실행을 잠깐 중단할 수 있는 `핀`이나 `전기 연결`을 포함한다.

> 인터럽트 시스템 동작 원리

1. 인터럽트 요청 신호 발생
2. 프로그램 실행 중단 : 보통은 현재 실행중인 명령까지는 끝까지 수행함
3. 현재 프로그램 상태 보존 : PC는 항상 다음번 실행할 명령의 주소를 가지고 있음
4. 인터럽트 처리 루틴 실행 : 인터럽트 백터를 보고 (인터럽트가 발생한) 장치 식별
5. 인터럽트 취급(서비스) 루틴 실행 (실질적인 인터럽트 처리)
6. 상태 복구
7. 중단된 프로그램 실행

`4`,`5`번이 `인터럽트 핸들러`에 해당하는 작업이다.

- 인터럽트 시스템은 서비스 후 돌아올 프로그램의 위치는 `Stack`에 저장한다. 인터럽트 핸들러는 자신이 덮어쓸 레지스터를 모두 저장해야 할 책임이 있다.

- 컴퓨터는 어떻게 `인터럽트 핸들러`의 위치는 보통 인터럽트 핸들러의 주소를 저장하기로 약속한 메모리 주소로 찾는다. 이 주소에 여러 `인터럽트 백터`가 들어있고, 인터럽트 백터는 CPU가 지원하는 각 인터럽트에 대한 핸들러 주소를 저장한다.`인터럽트 백터`는 메모리를 가리키는 `포인터`이다.