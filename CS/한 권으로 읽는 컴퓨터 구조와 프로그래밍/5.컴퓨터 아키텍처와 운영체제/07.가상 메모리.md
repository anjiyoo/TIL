- OS는 `MMU`를 사용해 메모리가 실제 메모리보다 많아 보이게 하는 기술인 가상 메모리를 제공한다.
- 메모리의 일부분을 디스크에 저장하여 사용하는 `디스크 스왑`이라고 불리는 것과는 별개의 기술이다. Windows에서 디스크 스왑 설정을 "가상 메모리" 라고 번역해서 혼동될 수 있다.

> 가상 메모리 장점

- 사용자가 기억 장소를 일일이 할당하는 불편을 없애준다.
- 프로세스의 크기가 실제 메모리의 용량을 초과해도 실행될 수가 있다.
- 설사 물리적 메모리의 용량이 충분히 커도 다중 프로그래밍이 가능하다.

> 가상 메모리와 MMU의 관계

![image66](https://github.com/user-attachments/assets/dde4babf-d0e5-4f99-ad70-47adfe3e24bb)

- `CPU`는 `가상 메모리 주소`만을 다루고 실제 해당 주소 접근 시 `MMU`를 통해 물리 메모리에 접근
- 하드웨어 장치를 이용해야 주소 변환이 빠르기 때문에 `MMU`라는 별도의 장치를 두고 있는 것
- `페이징 시스템`을 사용하면 프로세스에서 나눠진 page를 물리 메모리에 언제 올려 놓을지에 대한 정책이 필요하다. -> `요구불 페이징`

> 요구불 페이징 (Demand Paging)

- `Demand Paging`: 프로세스의 모든 데이터를 메모리로 적재하지 않고, 실행 중 필요한 시점에서만 메모리로 적재하는데 이 때 `valid/Invalid bit`가 사용된다.
- `Invalid/Valid Bit`: 사용되지 않는 주소 영역인 경우 페이지가 물리적 메모리에 없는 경우 (valid는 반대) 처음에는 모든 page가 invalid로 초기화되고 사용되면 valid로 되는데, address translation시에 invalid bit이라면 `page fault`가 발생한다.
- `Page fault`: 어떤 페이지가 물리 메모리에 없을 때 발생하는 인터럽트로 `Page fault`가 발생하면 운영체제가 해당 페이지를 물리 메모리에 올려준다.
- `Swap Out`: 요청 받은 메모리가 사용 가능한 메모리의 크기보다 크다면 현재 필요 없는 페이지를 느리지만 용량이 큰 디스크로 옮긴다.
- `Swap In`: `Swap Out`한 페이지로 접근이 필요하면 메모리 공간을 확보하고 해당 페이지를 다시 메모리로 불러들이는 것 이런 식으로 페이지 처리하는 것을 `요구불 페이징(Demand Paging)` 이라고 한다.

> 페이지 교체 정책 (Page Replacement policy) 알고리즘

운영체제가 특정 페이지를 물리 메모리에 올리려고 하는데 물리 메모리가 다 차 있다면 기존 페이지 중 하나를 물리 메모리에서 저장 매체로 내리고(저장) 새로운 페이지를 해당 물리 메모리 공간에 올려야 한다. 이 때 어떤 페이지를 물리 메모리에서, 저장 매체로 내릴 것 인가에 대한 것이 `페이지 교체 정책`이다.

1. `FIFO 알고리즘`: 가장 먼저 들어온 페이지를 내린다. (Queue)
2. `OPT(OPTimal) 알고리즘`: 앞으로 가장 오랫동안 사용하지 않을 페이지를 내린다는 최적 페이지 알고리즘.그러나 미래에 어떤 페이지를 얼마나 사용할 것인지는 알 수 없으므로 일반 OS에서는 구현이 불가하다. (실제 구현보다는 비교 연구 목적으로 사용)
3. `LRU(Least Recently Used) 알고리즘`: 가장 오래전에 사용된 페이지를 내리는 아이디어로 과거 기록을 기반으로 시도한 것이다. 많은 운영체제가 택하는 알고리즘으로 좋은 알고리즘이라 평가받고 있다.
4. `LFU(Least Frequently Used) 알고리즘`: 가장 적게 사용된 페이지를 내린다.
5. `NUR(Not Used Recently) 알고리즘`: LRU와 마찬가지로 최근에 사용하지 않은 페이지부터 내리는 알고리즘인데 각 페이지마다 참조 여부를 나타내는 비트(R), 수정 여부를 나타내는 비트(M)을 두어서 (0, 0), (0, 1), (1, 0), (1, 1) 순으로 교체한다.